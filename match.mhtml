From: <Saved by Blink>
Snapshot-Content-Location: http://synthcode.com/scheme/chibi/lib/chibi/match.html
Subject: 
Date: Sun, 12 Jul 2020 05:08:00 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--mUHWWZocyh84kYdeSgEbXbZ9rD8NqrgbYJq80AM57y----"


------MultipartBoundary--mUHWWZocyh84kYdeSgEbXbZ9rD8NqrgbYJq80AM57y----
Content-Type: text/html
Content-ID: <frame-230A5CC5B0F993A11229959E773459AD@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: http://synthcode.com/scheme/chibi/lib/chibi/match.html

<html><head><meta http-equiv=3D"Content-Type" content=3D"text/html; charset=
=3Dwindows-1252"><link rel=3D"stylesheet" type=3D"text/css" href=3D"cid:css=
-dbec288a-6590-4a32-9ef3-31a1f087554d@mhtml.blink" />

</head><body><div id=3D"menu"><ol><li><a href=3D"http://synthcode.com/schem=
e/chibi/lib/chibi/match.html#h2_Patterns">Patterns</a></li><li><a href=3D"h=
ttp://synthcode.com/scheme/chibi/lib/chibi/match.html#h2_Syntax">Syntax</a>=
<ol><li><a href=3D"http://synthcode.com/scheme/chibi/lib/chibi/match.html#h=
3_(matchexpr(pattern.body)...)(matchexpr(pattern(=3D%3Efailure).body)...)">=
match</a></li><li><a href=3D"http://synthcode.com/scheme/chibi/lib/chibi/ma=
tch.html#h3_match-lambda">match-lambda</a></li><li><a href=3D"http://synthc=
ode.com/scheme/chibi/lib/chibi/match.html#h3_match-lambda*">match-lambda*</=
a></li><li><a href=3D"http://synthcode.com/scheme/chibi/lib/chibi/match.htm=
l#h3_match-let">match-let</a></li><li><a href=3D"http://synthcode.com/schem=
e/chibi/lib/chibi/match.html#h3_match-letrec">match-letrec</a></li><li><a h=
ref=3D"http://synthcode.com/scheme/chibi/lib/chibi/match.html#h3_(match-let=
*((varvalue)...)body...)">match-let*</a></li></ol></li></ol></div><div id=
=3D"main"><div><a name=3D"h1_(chibimatch)"></a><h1>(chibi match)</h1></div>=
<p>
A portable hygienic pattern matcher.
This is a full superset of the popular <a href=3D"http://www.cs.indiana.edu=
/scheme-repository/code.match.html">match</a>
package by Andrew Wright, written in fully portable <code><span>syntax-rule=
s</span></code>
and thus preserving hygiene.
The most notable extensions are the ability to use <em>non-linear</em>
patterns - patterns in which the same identifier occurs multiple
times, tail patterns after ellipsis, and the experimental tree patterns.
</p><div><a name=3D"h2_Patterns"></a><h2>Patterns</h2></div><p>
Patterns are written to look like the printed representation of
the objects they match.  The basic usage is
<code>(<span class=3D"keyword">match</span> <span>expr</span> (pat <span>bo=
dy</span> <span>...</span>) <span>...</span>)</code>
where the result of <code>expr</code> is matched against each pattern in
turn, and the corresponding body is evaluated for the first to
succeed.  Thus, a list of three elements matches a list of three
elements.
</p><div><pre><code>(<span class=3D"keyword">let</span> ((ls (list <span>1<=
/span> <span>2</span> <span>3</span>))) (<span class=3D"keyword">match</spa=
n> <span>ls</span> ((1 <span>2</span> <span>3</span>) #t)))</code></pre><co=
de><div class=3D"result">=3D&gt; #t</div></code></div><p>
If no patterns match an error is signalled.
Identifiers will match anything, and make the corresponding
binding available in the body.
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span>) ((a <span>b</span> <span>c</span>) <span=
>b</span>))</code></pre><code><div class=3D"result">=3D&gt; 2</div></code><=
/div><p>
If the same identifier occurs multiple times, the first instance
will match anything, but subsequent instances must match a value
which is <code><span>equal?</span></code> to the first.
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>1</span>) ((a <span>a</span> <span>b</span>) <span=
>1</span>) ((a <span>b</span> <span>a</span>) <span>2</span>))</code></pre>=
<code><div class=3D"result">=3D&gt; 2</div></code></div><p>
The special identifier <code><span>_</span></code> matches anything, no mat=
ter how
many times it is used, and does not bind the result in the body.
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>1</span>) ((_ <span>_</span> <span>b</span>) <span=
>1</span>) ((a <span>b</span> <span>a</span>) <span>2</span>))</code></pre>=
<code><div class=3D"result">=3D&gt; 1</div></code></div><p>
To match a literal identifier (or list or any other literal), use
<code><span>quote</span></code>.
</p><div><pre><code>(<span class=3D"keyword">match</span> '<span>a</span> (=
'<span>b</span> <span>1</span>) ('<span>a</span> <span>2</span>))</code></p=
re><code><div class=3D"result">=3D&gt; 2</div></code></div><p>
Analogous to its normal usage in scheme, <code><span>quasiquote</span></cod=
e> can
be used to quote a mostly literally matching object with selected
parts unquoted.
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span>) (`(1 ,<span>b</span> ,<span>c</span>) (l=
ist <span>b</span> <span>c</span>)))</code></pre><code><div class=3D"result=
">=3D&gt; (2 3)</div></code></div><p>
Often you want to match any number of a repeated pattern.  Inside
a list pattern you can append <code><span>...</span></code> after an elemen=
t to
match zero or more of that pattern (like a regexp Kleene star).
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span>) ((1 <span>2</span> <span>3</span> <span>...</span>) #t)=
)</code></pre><code><div class=3D"result">=3D&gt; #t</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span>) ((1 <span>2</span> <span>3</span> <span>=
...</span>) #t))</code></pre><code><div class=3D"result">=3D&gt; #t</div></=
code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span> <span>3</span> <span>3</span>) ((1 <span>=
2</span> <span>3</span> <span>...</span>) #t))</code></pre><code><div class=
=3D"result">=3D&gt; #t</div></code></div><p>
Pattern variables matched inside the repeated pattern are bound to
a list of each matching instance in the body.
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span>) ((a <span>b</span> <span>c</span> <span>...</span>) <sp=
an>c</span>))</code></pre><code><div class=3D"result">=3D&gt; ()</div></cod=
e></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span>) ((a <span>b</span> <span>c</span> <span>=
...</span>) <span>c</span>))</code></pre><code><div class=3D"result">=3D&gt=
; (3)</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span> <span>4</span> <span>5</span>) ((a <span>=
b</span> <span>c</span> <span>...</span>) <span>c</span>))</code></pre><cod=
e><div class=3D"result">=3D&gt; (3 4 5)</div></code></div><p>
More than one <code><span>...</span></code> may not be used in the same lis=
t, since
this would require exponential backtracking in the general case.
However, <code><span>...</span></code> need not be the final element in the=
 list,
and may be succeeded by a fixed number of patterns.
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span> <span>4</span>) ((a <span>b</span> <span>=
c</span> <span>...</span> <span>d</span> <span>e</span>) <span>c</span>))</=
code></pre><code><div class=3D"result">=3D&gt; ()</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span> <span>4</span> <span>5</span>) ((a <span>=
b</span> <span>c</span> <span>...</span> <span>d</span> <span>e</span>) <sp=
an>c</span>))</code></pre><code><div class=3D"result">=3D&gt; (3)</div></co=
de></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</sp=
an> <span>7</span>) ((a <span>b</span> <span>c</span> <span>...</span> <spa=
n>d</span> <span>e</span>) <span>c</span>))</code></pre><code><div class=3D=
"result">=3D&gt; (3 4 5)</div></code></div><p>
<code><span>___</span></code> is provided as an alias for <code><span>...</=
span></code> when it is
inconvenient to use the ellipsis (as in a syntax-rules template).
The <code><span>..1</span></code> syntax is exactly like the <code><span>..=
.</span></code> except
that it matches one or more repetitions (like a regexp "+").
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span>) ((a <span>b</span> <span>c</span> <span>..1</span>) <sp=
an>c</span>))</code></pre><code><div class=3D"result">ERROR: match: "no mat=
ching pattern"
</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> (list <span>1</sp=
an> <span>2</span> <span>3</span>) ((a <span>b</span> <span>c</span> <span>=
..1</span>) <span>c</span>))</code></pre><code><div class=3D"result">=3D&gt=
; (3)</div></code></div><p>
The boolean operators <code><span>and</span></code>, <code><span>or</span><=
/code> and <code><span>not</span></code>
can be used to group and negate patterns analogously to their
Scheme counterparts.
The <code><span>and</span></code> operator ensures that all subpatterns mat=
ch.
This operator is often used with the idiom <code>(and <span>x</span> <span>=
pat</span>)</code> to
bind <code>x</code> to the entire value that matches <code>pat</code>
(c.f. "as-patterns" in ML or Haskell).  Another common use is in
conjunction with <code><span>not</span></code> patterns to match a general =
case
with certain exceptions.
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
and) #t))</code></pre><code><div class=3D"result">=3D&gt; #t</div></code></=
div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
and <span>x</span>) <span>x</span>))</code></pre><code><div class=3D"result=
">=3D&gt; 1</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
and <span>x</span> <span>1</span>) <span>x</span>))</code></pre><code><div =
class=3D"result">=3D&gt; 1</div></code></div><p>
The <code><span>or</span></code> operator ensures that at least one subpatt=
ern
matches.  If the same identifier occurs in different subpatterns,
it is matched independently.  All identifiers from all subpatterns
are bound if the <code><span>or</span></code> operator matches, but the bin=
ding is
only defined for identifiers from the subpattern which matched.
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
or) #t) (<span class=3D"keyword">else</span> #f))</code></pre><code><div cl=
ass=3D"result">=3D&gt; #f</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
or <span>x</span>) <span>x</span>))</code></pre><code><div class=3D"result"=
>=3D&gt; 1</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
or <span>x</span> <span>2</span>) <span>x</span>))</code></pre><code><div c=
lass=3D"result">=3D&gt; 1</div></code></div><p>
The <code><span>not</span></code> operator succeeds if the given pattern do=
esn't
match.  None of the identifiers used are available in the body.
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
not <span>2</span>) #t))</code></pre><code><div class=3D"result">=3D&gt; #t=
</div></code></div><p>
The more general operator <code><span>?</span></code> can be used to provid=
e a
predicate.  The usage is <code>(? <span>predicate</span> <span>pat</span> <=
span>...</span>)</code> where
<code>predicate</code> is a Scheme expression evaluating to a predicate
called on the value to match, and any optional patterns after the
predicate are then matched as in an <code><span>and</span></code> pattern.
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>1</span> ((=
? <span>odd?</span> <span>x</span>) <span>x</span>))</code></pre><code><div=
 class=3D"result">=3D&gt; 1</div></code></div><p>
The field operator <code><span>=3D</span></code> is used to extract an arbi=
trary
field and match against it.  It is useful for more complex or
conditional destructuring that can't be more directly expressed in
the pattern syntax.  The usage is <code>(=3D <span>field</span> <span>pat</=
span>)</code>, where
<code>field</code> can be any expression, and should result in a
procedure of one argument, which is applied to the value to match
to generate a new value to match against <code>pat</code>.
Thus the pattern <code>(and (=3D <span>car</span> <span>x</span>) (=3D <spa=
n>cdr</span> <span>y</span>))</code> is equivalent
to <code>(x <span>.</span> <span>y</span>)</code>, except it will result in=
 an immediate error
if the value isn't a pair.
</p><div><pre><code>(<span class=3D"keyword">match</span> '(1 <span>.</span=
> <span>2</span>) ((=3D <span>car</span> <span>x</span>) <span>x</span>))</=
code></pre><code><div class=3D"result">=3D&gt; 1</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> <span>4</span> ((=
=3D <span>square</span> <span>x</span>) <span>x</span>))</code></pre><code>=
<div class=3D"result">=3D&gt; 16</div></code></div><p>
The record operator <code><span>$</span></code> is used as a concise way to=
 match
records defined by SRFI-9 (or SRFI-99).  The usage is
<code>($ <span>rtd</span> <span>field</span> <span>...</span>)</code>, wher=
e <code>rtd</code> should be the record
type descriptor specified as the first argument to
<code><span>define-record-type</span></code>, and each <code>field</code> i=
s a subpattern
matched against the fields of the record in order.  Not all fields
must be present.
</p><div><pre><code>(<span class=3D"keyword">let</span> ()
  (<span class=3D"keyword">define-record-type</span> <span class=3D"functio=
n">employee</span>
    (make-employee <span>name</span> <span>title</span>)
    <span>employee?</span>
    (name <span>get-name</span>)
    (title <span>get-title</span>))
  (<span class=3D"keyword">match</span> (make-employee <span class=3D"strin=
g">"Bob"</span> <span class=3D"string">"Doctor"</span>)
    (($ <span>employee</span> <span>n</span> <span>t</span>) (list <span>t<=
/span> <span>n</span>))))
</code></pre><code><div class=3D"result">=3D&gt; ("Doctor" "Bob")</div></co=
de></div><p>
For records with more fields it can be helpful to match them by
name rather than position.  For this you can use the <code><span>@</span></=
code>
operator, originally a Gauche extension:
</p><div><pre><code>(<span class=3D"keyword">let</span> ()
  (<span class=3D"keyword">define-record-type</span> <span class=3D"functio=
n">employee</span>
    (make-employee <span>name</span> <span>title</span>)
    <span>employee?</span>
    (name <span>get-name</span>)
    (title <span>get-title</span>))
  (<span class=3D"keyword">match</span> (make-employee <span class=3D"strin=
g">"Bob"</span> <span class=3D"string">"Doctor"</span>)
    ((@ <span>employee</span> (title <span>t</span>) (name <span>n</span>))=
 (list <span>t</span> <span>n</span>))))
</code></pre><code><div class=3D"result">=3D&gt; ("Doctor" "Bob")</div></co=
de></div><p>
The <code><span>set!</span></code> and <code><span>get!</span></code> opera=
tors are used to bind an
identifier to the setter and getter of a field, respectively.  The
setter is a procedure of one argument, which mutates the field to
that argument.  The getter is a procedure of no arguments which
returns the current value of the field.
</p><div><pre><code>(<span class=3D"keyword">let</span> ((x (cons <span>1</=
span> <span>2</span>))) (<span class=3D"keyword">match</span> <span>x</span=
> ((1 <span>.</span> (<span class=3D"keyword">set!</span> <span>s</span>)) =
(s <span>3</span>) <span>x</span>)))</code></pre><code><div class=3D"result=
">=3D&gt; (1 . 3)</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> '(1 <span>.</span=
> <span>2</span>) ((1 <span>.</span> (get! <span>g</span>)) (g)))</code></p=
re><code><div class=3D"result">=3D&gt; 2</div></code></div><p>
The new operator <code><span>***</span></code> can be used to search a tree=
 for
subpatterns.  A pattern of the form <code>(x <span>***</span> <span>y</span=
>)</code> represents
the subpattern <code>y</code> located somewhere in a tree where the path
from the current object to <code>y</code> can be seen as a list of the
form <code>(x <span>...</span>)</code>.  <code>y</code> can immediately mat=
ch the current
object in which case the path is the empty list.  In a sense it's
a 2-dimensional version of the <code><span>...</span></code> pattern.
As a common case the pattern <code>(_ <span>***</span> <span>y</span>)</cod=
e> can be used to
search for <code>y</code> anywhere in a tree, regardless of the path
used.
</p><div><pre><code>(<span class=3D"keyword">match</span> '(a (a (a <span>b=
</span>))) ((x <span>***</span> '<span>b</span>) <span>x</span>))</code></p=
re><code><div class=3D"result">=3D&gt; (a a a)</div></code></div><p>
</p><div><pre><code>(<span class=3D"keyword">match</span> '(a (b) (c (d <sp=
an>e</span>) (f <span>g</span>))) ((x <span>***</span> '<span>g</span>) <sp=
an>x</span>))</code></pre><code><div class=3D"result">=3D&gt; (a c f)</div>=
</code></div><div><a name=3D"h2_Syntax"></a><h2>Syntax</h2></div><p>
</p><div><a name=3D"h3_(matchexpr(pattern.body)...)(matchexpr(pattern(=3D>f=
ailure).body)...)"></a><h3><code>(match expr (pattern . body) ...)<br><br>
(match expr (pattern (=3D&gt; failure) . body) ...)</code></h3></div><p>
The result of <code>expr</code> is matched against each <code>pattern</code=
> in
turn, according to the pattern rules described in the previous
section, until the the first <code>pattern</code> matches.  When a match is
found, the corresponding <code>body</code>s are evaluated in order,
and the result of the last expression is returned as the result
of the entire <code><span>match</span></code>.  If a <code>failure</code> i=
s provided,
then it is bound to a procedure of no arguments which continues,
processing at the next <code>pattern</code>.  If no <code>pattern</code> ma=
tches,
an error is signalled.</p><div><a name=3D"h3_match-lambda"></a><h3><code>(m=
atch-lambda (pattern . body) ...)</code></h3></div><p>Shortcut for <code><s=
pan>lambda</span></code> + <code><span>match</span></code>.  Creates a
procedure of one argument, and matches that argument against each
clause.</p><div><a name=3D"h3_match-lambda*"></a><h3><code>(match-lambda* (=
pattern . body) ...)</code></h3></div><p>Similar to <code><span>match-lambd=
a</span></code>.  Creates a procedure of any
number of arguments, and matches the argument list against each
clause.</p><div><a name=3D"h3_match-let"></a><h3><code>(match-let ((var val=
ue) ...) . body)<br><br>(match-let loop ((var init) ...) . body)</code></h3=
></div><p>Matches each var to the corresponding expression, and evaluates
the body with all match variables in scope.  Raises an error if
any of the expressions fail to match.  Syntax analogous to named
let can also be used for recursive functions which match on their
arguments as in <code><span>match-lambda*</span></code>.</p><div><a name=3D=
"h3_match-letrec"></a><h3><code>(match-letrec ((var value) ...) . body)</co=
de></h3></div><p>Similar to <code><span>match-let</span></code>, but analog=
ously to <code><span>letrec</span></code>
matches and binds the variables with all match variables in scope.</p><div>=
<a name=3D"h3_(match-let*((varvalue)...)body...)"></a><h3><code>(match-let*=
 ((var value) ...) body ...)</code></h3></div><p>
Similar to <code><span>match-let</span></code>, but analogously to <code><s=
pan>let*</span></code>
matches and binds the variables in sequence, with preceding match
variables in scope.</p><div id=3D"footer"></div></div></body></html>
------MultipartBoundary--mUHWWZocyh84kYdeSgEbXbZ9rD8NqrgbYJq80AM57y----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-dbec288a-6590-4a32-9ef3-31a1f087554d@mhtml.blink

@charset "windows-1252";

body { color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); }

div#menu { font-size: smaller; position: absolute; top: 50px; left: 0px; wi=
dth: 190px; height: 100%; }

div#main { position: absolute; top: 0px; left: 200px; width: 540px; height:=
 100%; }

div#notes { position: relative; top: 2em; left: 570px; max-width: 200px; he=
ight: 0px; font-size: smaller; }

div#footer { padding-bottom: 50px; }

.result { color: rgb(0, 0, 0); background-color: rgb(255, 234, 223); width:=
 100%; padding: 3px; }

.command { color: rgb(0, 0, 0); background-color: rgb(255, 234, 223); width=
: 100%; padding: 5px; }

.keyword { color: rgb(128, 0, 128); background-color: inherit; }

.type { color: rgb(0, 128, 0); background-color: inherit; }

.function { color: rgb(0, 0, 255); background-color: inherit; }

.variable { color: rgb(184, 134, 11); background-color: inherit; }

.comment { color: rgb(255, 0, 0); background-color: inherit; }

.string { color: rgb(188, 143, 143); background-color: inherit; }

.attribute { color: rgb(255, 80, 0); background-color: inherit; }

.preprocessor { color: rgb(255, 0, 255); background-color: inherit; }

.builtin { color: rgb(255, 0, 255); background-color: inherit; }

.character { color: rgb(0, 85, 170); background-color: inherit; }

.syntaxerror { color: rgb(255, 0, 0); background-color: inherit; }

.diff-deleted { color: rgb(95, 33, 33); background-color: inherit; }

.diff-added { color: rgb(33, 95, 33); background-color: inherit; }

span.paren1 { color: rgb(170, 170, 170); background-color: inherit; }

span.paren2 { color: rgb(136, 136, 136); background-color: inherit; }

span.paren3 { color: rgb(102, 102, 102); background-color: inherit; }

span.paren4 { color: rgb(68, 68, 68); background-color: inherit; }

span.paren5 { color: rgb(34, 34, 34); background-color: inherit; }

span.paren6 { color: rgb(0, 0, 0); background-color: inherit; }
------MultipartBoundary--mUHWWZocyh84kYdeSgEbXbZ9rD8NqrgbYJq80AM57y------
